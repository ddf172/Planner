# Algorithm Architecture Documentation

## Core Philosophy

This architecture is designed around **maximum algorithm freedom** - algorithms are completely independent executables that can implement any scheduling approach without framework constraints. The system provides data and expects results, nothing more.

## System Integration Overview

### Adding Algorithm Support to Existing System

The current project has a robust message handling system with `MessageType` enum supporting Data, Command, and Debug messages. We extend this by adding a fourth type:

```cpp
// In ScheduleData.hpp - extend existing enum
enum class MessageType {
    Data = 0,
    Command = 1, 
    Debug = 2,
    Algorithm = 3    // NEW - handles all algorithm operations
};
```

This single message type handles all algorithm-related operations through different command payloads, maintaining consistency with the existing handler pattern.

### Message Flow Architecture

```
Client Request → ServerSocket → MessageProcessor → System::handleCompleteMessage → HandlerDispatcher → AlgorithmHandler
                                                                                                              ↓
Algorithm Process ← JSON Files ← System::AlgorithmRunner ←──────────────────────────────────────────────────┘
                                                         ↓
Result JSON → System::AlgorithmRunner → AlgorithmHandler → System::sendMessage → Client Response
```

The integration leverages existing infrastructure:
- Uses current MessageProcessor for message assembly
- Follows established handler pattern (like DataHandler, DebugHandler, CommandHandler)
- Uses existing HandlerDispatcher in System for message routing
- AlgorithmRunner lives in System (not in handler) for shared access
- Reuses existing JSON serialization via nlohmann::json
- Maintains current error handling and response mechanisms

## Algorithm Interface Specification

### Universal Executable Contract

Every algorithm must implement this exact interface:

```bash
./algorithm input.json output.json [config.json]
```

**Parameters:**
- `input.json` - Complete scheduling data (generated by system)
- `output.json` - Algorithm results (parsed by system) 
- `config.json` - Optional algorithm-specific parameters

**Return Codes:**
- `0` - Success: valid schedule generated in output.json
- `1` - No solution: algorithm couldn't find valid schedule within constraints
- `2` - Invalid input: malformed or incomplete input data
- `3` - Algorithm error: internal algorithm failure or crash

This contract ensures algorithms can be developed, tested, and deployed independently of the main system.

### Data Exchange Format

#### Input Data Structure
The system generates input.json containing all scheduling data using existing ScheduleData structures:

```json
{
    "timeBlocks": [
        {
            "id": 1,
            "dayOfWeek": 0,
            "startTime": "08:00", 
            "endTime": "09:30"
        }
    ],
    "subjects": [
        {
            "id": 1,
            "name": "Mathematics",
            "duration": 90,
            "type": "lecture"
        }
    ],
    "groups": [
        {
            "id": 1,
            "name": "Group A", 
            "size": 25
        }
    ],
    "rooms": [
        {
            "id": 1,
            "name": "Room 101",
            "capacity": 30,
            "type": "classroom"
        }
    ],
    "teachers": [
        {
            "id": 1,
            "name": "Dr. Smith",
            "specialization": "Mathematics"
        }
    ],
    "constraints": [
        {
            "id": 1,
            "type": "RoomCapacity",
            "weight": 1.0,
            "data": {}
        }
    ]
}
```

This format uses the exact same structures defined in ScheduleData.hpp, ensuring consistency and leveraging existing JSON serialization.

#### Output Data Structure
Algorithm must produce valid JSON with this structure:

```json
{
    "status": "success",
    "schedule": {
        "events": [
            {
                "id": 1,
                "subjectId": 1,
                "groupId": 1, 
                "roomId": 1,
                "teacherId": 1,
                "timeBlockId": 1
            }
        ]
    },
    "metadata": {
        "algorithmName": "genetic_v1",
        "version": "1.0",
        "executionTimeMs": 15000,
        "qualityScore": 0.85,
        "constraintViolations": 0,
        "customMetrics": {
            "generations": 150,
            "populationSize": 200,
            "convergenceGeneration": 120
        }
    }
}
```

**Status Values:**
- `"success"` - Valid schedule generated
- `"no_solution"` - No valid schedule found
- `"error"` - Algorithm failed (include errorMessage field)

**Required Fields:**
- `status` - Always required
- `schedule.events` - Required if status is "success"
- `metadata.algorithmName` - Algorithm identification
- `metadata.executionTimeMs` - Performance tracking

**Optional Fields:**
- `metadata.qualityScore` - Algorithm-defined quality metric (0.0-1.0)
- `metadata.constraintViolations` - Number of violated constraints
- `metadata.customMetrics` - Algorithm-specific data
- `errorMessage` - Detailed error description (if status is "error")

## Algorithm Command Protocol

### Command Structure
All algorithm operations use MessageType::Algorithm with operation specified in JSON payload:

```json
{
    "algorithm": "operation_name",
    "parameter1": "value1",
    "parameter2": "value2"
}
```

### Supported Operations

#### List Available Algorithms
```json
{
    "algorithm": "list"
}
```

**Response:**
```json
{
    "status": "success",
    "algorithms": [
        {
            "name": "genetic_basic",
            "displayName": "Genetic Algorithm Basic",
            "version": "1.0",
            "description": "Basic genetic algorithm implementation",
            "type": "genetic",
            "supportsProgress": true,
            "parameters": {
                "populationSize": {"type": "int", "default": 100, "min": 10, "max": 1000},
                "maxGenerations": {"type": "int", "default": 200, "min": 10, "max": 2000}
            }
        }
    ]
}
```

#### Run Algorithm
```json
{
    "algorithm": "run",
    "name": "genetic_basic",
    "data": {
        "timeBlocks": [...],
        "subjects": [...],
        "groups": [...],
        "rooms": [...], 
        "teachers": [...],
        "constraints": [...]
    },
    "config": {
        "populationSize": 200,
        "maxGenerations": 500,
        "mutationRate": 0.05
    }
}
```

**Response (immediate):**
```json
{
    "status": "started",
    "runId": "uuid-string",
    "estimatedDuration": "30-60 seconds"
}
```

#### Stop Algorithm
```json
{
    "algorithm": "stop"
}
```

#### Get Status/Progress
```json
{
    "algorithm": "status"
}
```

**Response:**
```json
{
    "status": "running|completed|failed|stopped",
    "progress": 0.67,
    "currentPhase": "optimizing",
    "result": {...}  // Only if completed
}
```

## Algorithm Registry System

### Directory Structure
```
algorithms/
├── genetic_basic/
│   ├── algorithm               # Executable file
│   └── info.json              # Algorithm metadata
├── simulated_annealing/
│   ├── algorithm
│   └── info.json
├── neural_network/
│   ├── algorithm
│   └── info.json
└── tabu_search/
    ├── algorithm
    └── info.json
```

### Algorithm Metadata (info.json)
Each algorithm directory must contain info.json with complete metadata:

```json
{
    "name": "genetic_basic",
    "displayName": "Genetic Algorithm Basic",
    "version": "1.0",
    "description": "Basic genetic algorithm implementation for schedule optimization",
    "author": "Algorithm Development Team",
    "type": "genetic",
    "supportsProgress": true,
    "parameters": {
        "populationSize": {
            "type": "int",
            "default": 100,
            "min": 10,
            "max": 1000,
            "description": "Number of individuals in the genetic algorithm population"
        },
        "maxGenerations": {
            "type": "int",
            "default": 200, 
            "min": 10,
            "max": 2000,
            "description": "Maximum number of generations to evolve"
        }
    }
}
```

**Field Explanations:**
- `name` - Unique identifier (matches directory name)
- `displayName` - Human-readable name for UI
- `type` - Algorithm category (genetic, simulated_annealing, neural_network, etc.)
- `supportsProgress` - Whether algorithm can provide progress updates
- `parameters` - Configurable algorithm parameters with validation rules

## Progress Reporting (Optional Feature)

### Real-time Progress Updates
Algorithms can optionally provide progress updates by writing to a designated progress file. The system provides the progress file path as a command line argument:

```bash
./algorithm input.json output.json config.json progress.json
```

### Progress File Format
```json
{
    "progress": 0.67,
    "status": "optimizing",
    "currentBest": {
        "qualityScore": 0.78,
        "constraintViolations": 2
    },
    "algorithmSpecific": {
        "currentGeneration": 134,
        "populationDiversity": 0.45
    }
}
```

**Progress Values:**
- `progress` - Completion percentage (0.0 to 1.0)
- `status` - Current phase: "initializing", "optimizing", "finalizing"
- `currentBest` - Best solution found so far
- `algorithmSpecific` - Any algorithm-defined metrics

The system polls this file periodically to provide real-time updates to clients.
- `status` - Current phase: "initializing", "optimizing", "finalizing"
- `currentBest` - Best solution found so far
- `algorithmSpecific` - Any algorithm-defined metrics
- `estimatedTimeRemaining` - Milliseconds until completion (optional)

The system polls this file periodically to provide real-time updates to clients.

## System Implementation Details

### AlgorithmHandler Class
```cpp
class AlgorithmHandler : public IMessageHandler {
public:
    void handle(const std::string& messageId, const std::string& payload, System& system) override;
    MessageType getHandledType() const override { return MessageType::Algorithm; }
    
private:
    void handleList(const std::string& messageId, System& system);
    void handleRun(const std::string& messageId, const json& request, System& system);
    void handleStop(const std::string& messageId, System& system);
    void handleStatus(const std::string& messageId, System& system);
};
```

The handler follows the established pattern used by DataHandler, DebugHandler, and CommandHandler, ensuring consistency with existing code architecture. **Important:** The handler only routes commands to System methods - it does NOT manage AlgorithmRunner directly.

### System Class Extensions
```cpp
class System {
private:
    // ... existing members ...
    std::unique_ptr<AlgorithmRunner> algorithmRunner;  // NEW - owned by System
    
public:
    // ... existing methods ...
    
    // NEW - Algorithm management methods
    std::vector<AlgorithmInfo> listAlgorithms();
    bool startAlgorithm(const std::string& algorithmName, const json& inputData, const json& config);
    bool stopAlgorithm();
    json getAlgorithmStatus();
    json getAlgorithmResult();
};
```

### AlgorithmRunner Class
```cpp
class AlgorithmRunner {
public:
    bool start(const std::string& algorithmPath, const json& inputData, const json& config);
    void stop();
    bool isRunning() const;
    float getProgress() const;
    std::string getStatus() const;
    json getResult();
    
private:
    std::string algorithmPath;
    std::string inputFile;
    std::string outputFile;
    std::string configFile;
    std::string progressFile;
    std::thread processThread;
    std::atomic<bool> running;
    std::atomic<bool> stopRequested;
    std::atomic<float> progress;
    json resultData;
    std::string statusMessage;
    int exitCode;
    
    void runAlgorithmProcess();
    void monitorProgress();
    void cleanupTempFiles();
    std::string generateTempFile(const std::string& prefix);
    bool validateResult(const json& result);
};
```

### AlgorithmInfo Structure
```cpp
struct AlgorithmInfo {
    std::string name;
    std::string displayName;
    std::string path;
    std::string version;
    std::string description;
    std::string author;
    std::string type;
    bool supportsProgress;
    std::string estimatedRuntime;
    json parameters;
    
    static AlgorithmInfo fromInfoFile(const std::string& infoPath);
    bool isValid() const;
    std::vector<std::string> validateParameters(const json& config) const;
};
```

## Implementation Roadmap

### Phase 1: Core Integration (2-3 days)
1. **Extend MessageType enum** in ScheduleData.hpp
2. **Create AlgorithmHandler class** following existing handler pattern
3. **Extend System class** with AlgorithmRunner and algorithm management methods
4. **Create basic AlgorithmRunner** for process management
5. **Update main.cpp** to register AlgorithmHandler

### Phase 2: Algorithm Registry (1-2 days)
1. **Implement algorithm discovery** in algorithms/ directory
2. **Create metadata parsing** for info.json files
3. **Add algorithm validation** (executable exists, info.json valid, parameters valid)
4. **Implement algorithm listing** functionality in System

### Phase 3: Algorithm Execution (2-3 days)
1. **Implement process spawning** with proper isolation
2. **Add temporary file management** for input/output/config/progress
3. **Create progress monitoring** system (optional feature)
4. **Add result parsing and validation**
5. **Implement process termination** and cleanup

### Phase 4: Error Handling & Polish (1-2 days)
1. **Add comprehensive error handling** for all failure scenarios
2. **Implement timeout handling** for long-running algorithms
3. **Add resource cleanup** for interrupted processes
4. **Create algorithm crash recovery**
5. **Add logging and debugging support**

## Algorithm Development Guide

### Creating a New Algorithm

#### Step 1: Create Algorithm Directory
```bash
mkdir algorithms/my_algorithm
cd algorithms/my_algorithm
```

#### Step 2: Implement Algorithm Executable
Create your algorithm as a standard C++ program:

```cpp
// main.cpp
#include <iostream>
#include <fstream>
#include <nlohmann/json.hpp>

using json = nlohmann::json;

int main(int argc, char* argv[]) {
    if (argc < 3) {
        std::cerr << "Usage: " << argv[0] << " input.json output.json [config.json]" << std::endl;
        return 2;
    }
    
    try {
        // Read input data
        std::ifstream inputFile(argv[1]);
        json inputData;
        inputFile >> inputData;
        
        // Read config if provided
        json config;
        if (argc > 3) {
            std::ifstream configFile(argv[3]);
            configFile >> config;
        }
        
        // YOUR ALGORITHM IMPLEMENTATION HERE
        // You have complete freedom to implement any scheduling approach
        
        // Generate result
        json result;
        result["status"] = "success";
        result["schedule"]["events"] = /* your generated events */;
        result["metadata"]["algorithmName"] = "my_algorithm";
        result["metadata"]["executionTimeMs"] = /* execution time */;
        
        // Write output
        std::ofstream outputFile(argv[2]);
        outputFile << result.dump(2);
        
        return 0;
    } catch (const std::exception& e) {
        // Write error result
        json errorResult;
        errorResult["status"] = "error";
        errorResult["errorMessage"] = e.what();
        
        std::ofstream outputFile(argv[2]);
        outputFile << errorResult.dump(2);
        
        return 3;
    }
}
```

#### Step 3: Create Algorithm Metadata
Create info.json with complete algorithm information:

```json
{
    "name": "my_algorithm",
    "displayName": "My Custom Algorithm",
    "version": "1.0",
    "description": "Custom scheduling algorithm implementation",
    "author": "Your Name",
    "type": "custom",
    "supportsProgress": false,
    "estimatedRuntime": "5-30 seconds",
    "parameters": {
        "iterations": {
            "type": "int",
            "default": 1000,
            "min": 100,
            "max": 10000,
            "description": "Number of optimization iterations"
        }
    }
}
```

#### Step 4: Build and Test
```bash
# Compile your algorithm
g++ -std=c++17 -o algorithm main.cpp

# Test independently
./algorithm ../../data/input_data.json test_output.json test_config.json test_progress.json

# Check exit code and output
echo $?
cat test_output.json
```

#### Step 5: Deploy
Copy your algorithm directory to the algorithms/ folder and it will be automatically discovered by the system.

### Testing Strategy

#### Independent Testing
Test your algorithm without the main system:

```bash
# Create test input
cat > test_input.json << 'EOF'
{
    "timeBlocks": [...],
    "subjects": [...],
    // etc.
}
EOF

# Run algorithm
./algorithm test_input.json test_output.json test_config.json test_progress.json
echo "Exit code: $?"
cat test_output.json
```

#### Integration Testing
Test through the message system by sending JSON messages via the existing client connection.

## Benefits and Design Rationale

### For Algorithm Developers
- **Complete Implementation Freedom**: No framework constraints, use any approach, data structures, or optimization techniques
- **Independent Development**: Develop and test algorithms without running the full system
- **Simple Deployment**: Copy executable and metadata file to deploy
- **No Dependencies**: No libraries to link against, no APIs to learn
- **Easy Debugging**: Standard debugging tools work, can run algorithm in isolation

### For System Integration
- **Minimal Code Changes**: Single MessageType addition leverages existing infrastructure
- **Robust Error Handling**: Algorithm crashes don't affect main system
- **Resource Isolation**: Each algorithm runs in separate process
- **Consistent Interface**: Follows established handler pattern
- **Easy Maintenance**: Clear separation between system and algorithm code

### For Users
- **Multiple Algorithm Options**: Choose the best algorithm for specific scheduling needs
- **Transparent Progress**: See real-time algorithm progress and status
- **Reliable Operation**: Algorithm failures are handled gracefully
- **Configurable Parameters**: Adjust algorithm behavior through parameters
- **Performance Insights**: View execution time, quality scores, and custom metrics

This architecture achieves the goal of maximum algorithm freedom while maintaining clean integration with the existing robust message handling system.
